$ $是注释
$空格是间隔
$将{} [] 全部转成对应文法 将单引号去除
$将文法扩展

<S> ::=<Program>

<Program> ::= <N> <声明串>
$语义 将main的地址回填到N的nextlist

<N> ::=空
$语义 N.nextlist={nextquad}
$语义 emit(j,_,_,-1)

<声明串> ::=<声明>|<声明> <声明串>
$语义 无 压栈出栈即可

<声明> ::=int  ID <M> <A> <声明类型> | void  ID <M> <A>  <函数声明>|float  ID <M> <A> <声明类型>
$语义 对于声明类型 如果是变量声明 此处形成一个完整的变量声明 将变量名 类型 （变量层次）加入变量表
$语义 对于声明类型 如果是函数声明 此处形成一个完整的函数声明 将函数名 类型 参数表 函数地址加入函数表
$语义 对于函数声明 此处形成一个完整的函数声明 将函数名 类型 参数表 函数地址加入函数表

<M> ::= 空
$语义 M.quad=nextquad

<A> ::= 空
$语义 nowLevel为当前层级 nowLevel++

<声明类型>::=<变量声明> | <函数声明>
$语义 对于变量声明 记录当前声明类型为变量
$语义 对于函数声明 直接传递参数表等属性

<变量声明> ::=  ;
$语义 无 压栈出栈即可

<函数声明> ::= ( <形参> ) <语句块> 
$语义 将左侧的形参列表置为<形参>的形参列表 类型为函数声明

<形参>::= <参数列表> | void
$语义 对于参数列表 将左侧的形参列表置为<参数列表>的形参列表
$语义 对于void 将左侧的形参列表置为空

<参数列表>  ::= <参数> <逗号和参数>
$语义 将左侧的参数列表置为右侧的参数的合并 包括数据类型等信息

<逗号和参数> ::= , <参数> <逗号和参数>|空

$语义 将左侧的参数列表置为右侧的参数的合并 包括数据类型等信息
$语义 若为空 则直接产生空参数列表

<参数> ::= int  ID|float  ID 
$语义 将左侧的形参列表置为一个参数 类型为 int|float 名为 ID

<语句块> ::= { <内部声明>  <语句串> }
$语义 nowLevel--
$语义 <语句块>nextlist=<语句串>nextlist


<内部声明> ::= 空 | <内部变量声明> ; <内部声明>
$语义 无 压栈出栈即可

<内部变量声明>::=int  ID|float  ID
$语义 此处形成一个完整的变量声明 将变量名 类型 （变量层次）加入变量表

<语句串> ::= <语句> <M> |<语句> <M> <语句串>
$语义 <语句> 将右侧 nextList 传递给左侧
$语义 <语句> <M> <语句串> 将右侧 nextList 传递给左侧 用M回填

<语句> ::= <if语句> |<while语句> | <return语句> | <赋值语句>
$语义 前两个 将右侧 nextList 传递给左侧
$语义 后面的 nextlist为空 考虑不处理（？）

<赋值语句> ::=  ID = <表达式> ; 
$语义 生成赋值四元式

<return语句> ::= return <表达式> ;|return ;
$语义 生成返回四元式

<while语句> ::= while <M> ( <表达式> ) <A> <语句块>
$语义 M. quad 回填到语句块 nextList
$语义 左侧 nextList=表达式 falselist
$语义 生成 jump 四元式


<if语句> ::= if  ( <表达式> )  <A> <语句块>  |if  ( <表达式> ) <A>  <语句块> <N> else <M> <A> <语句块>
$语义 第一个产生式
$语义 表达式 falseList 后面加上 A.falseList 语句块 nextList
$语义 If 语句 nextList 设置为表达式 falseList
$语义 第2个产生式前面一致
$语义 M.quad 回填到表达式 falseList
$语义 Merge nextList 作为 if 语句的 nextList

<表达式>::=<加法表达式>|<加法表达式> <relop> <加法表达式>
$语义 传递中间变量名
$后一句
$语义 向表达式 falseList 中加入当前 quad
$语义 生成 jump 四元式

<relop>::=<|<=|>|>=|==|!=
$语义 传递 relop 符号类型

<加法表达式> ::= <项> |<项> + <加法表达式>|<项> - <加法表达式>
$语义 申请新的中间变量
$语义 生成对应四元式，使得右侧结果存入
$加上属性falselist=-1 如果在relop两边则回填

<项> ::= <因子>| <因子> * <项>|<因子> / <项>
$语义 因子的变量名作为项的变量名
$第二个
$语义 申请新的中间变量
$语义 生成对应四元式，使得右侧结果存入

<因子> ::=num |  ( <表达式> )  |ID  |ID ( <实参列表> ) 
$语义  将 Num 计入因子中
$语义 表达式的中间变量名作为因子的变量名
$语义 将 ID 的变量名作为因子的变量名
$语义 过程调用
$语义 检查是否能找到对应的函数名
$语义 检查实参列表的个数能否和函数的形参列表个数匹配
$语义生成参数压栈四元式
$语义 生成过程调用相关其他四元式
$语义 申请中间变量，生成 return 相关四元式

<实参列表> ::=<表达式>| <表达式> , <实参列表>|空
$实参列表置为<表达式>的中间变量名
$左侧实参列表置为<表达式>的中间变量名+右侧实参列表
$空直接出栈入栈

<内部声明> ::= <内部数组声明> ; <内部声明>
<内部数组声明> ::= int ID <数组>
<数组> ::= [ num ]
<数组> ::= [ num ] <数组>
<赋值语句> ::= ID <数组> = <表达式> ;
<因子> ::= ID <数组>







